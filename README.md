# Тестовое задание 29

Цель нашего тестового задания - это определить уровень ваших знаний и навыков по разработке бэкенда веб-приложения. Тестовое задание сформулировано без каких-то жёстких требований, но просим при реализации учитывать лучшую практику из вашего опыта по оформлению кода и репозитория, обеспечению безопасности, производительности и командной работе. Пожалуйста, помните, что код и API должны быть не только рабочими, но и стабильными, понятными и удобными в использовании.
Подготовка

Создайте новый публичный репозиторий на Gitlab.com, его нужно назвать “test29”. Пришлите на него ссылку по итогу тестового.
Установите последнюю версию фреймворка Laravel (12.x).

---

### models:

| Марка автомобиля  |
|-------------------|
| Название          |

| Модель автомобиля                  |
|------------------------------------|
| Название                           |
| Марка                              |                              

| Автомобиль                         |                         
|------------------------------------|
| Модель                             |                             
| Год выпуска (опциональный атрибут) | 
| Пробег (опциональный атрибут)      |       
| Цвет (опциональный атрибут)        |     
| Id пользователя                    |

---

| API endpoints              |
|----------------------------|
| Список марок автомобилей   |    
| Список моделей автомобилей | 
| Список + CRUD автомобилей  |

---

### Дополнительное задание (выполняется по желанию)
Привязать автомобиль к пользователю и разрешить пользователям доступ только к “своим” автомобилям.


# Прошу не пропускать
### Быстрое пояснение итогов и логики.
Разработал несколько доменов с упором на задание. 
Каждый домен имеет свой bounded context, автоматическую маршрутирезацию и подтягивание локальных миграций контекста.

### 1. Application layer
Содержит поднастройки для приложения и делиться на несколько частей:

> #### Route service provider:
> 1. Провайдер берет все домены и контексты из `config(domains.dataloft)`
> 2. К каждому контексту автоматически генерируются 2 префикса - `{domain}/{boundedContext}/my_route`
> Такой способ добавляет гибкости проекту при разработке разной доменной оси.

> #### Migration service provider:
> 1. Загружает все пути к миграциям из доменной модели

> #### Config service provider:
> 1. Подгружает все конфиги

> #### Cache
> 1. Содержит конфиг для доп. настроек кеширования в зависимости от приложения
> 2. Содержит use case, который генерирует ключ по uri

В идеале добавить консольную команду для автоматической генерации bounded context'ов в своих доменах + генерацию к ним stub'ов по остальным сущностям (модели, ресурсы и т.д.)
плюс дооптимизировать алгосы которые есть сейчас в провайдерах

- заворачиваю кеши/сессию в redis по разным БД
- все индексные статичные ответы, где используется пагинация кладу в кеш 
- Контроллеры юзают кастомный метод `asJson()`, который гарантирует единый интерфейс


профилировка:
- psalm
- telescope
